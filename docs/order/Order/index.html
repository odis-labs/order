<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Order (order.Order)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">order</a> &#x00BB; Order</nav><h1>Module <code>Order</code></h1><p>Functionality for comparison and ordering of OCaml values.</p><nav class="toc"><ul><li><a href="#ordering">Ordering</a><ul><li><a href="#examples">Examples</a></li><li><a href="#equality">Equality</a><ul><li><a href="#examples">Examples</a></li><li><a href="#equality_functions">Equality functions</a></li><li><a href="#equal">Monomorphic Types</a></li><li><a href="#equal1">Polymorphic Unary Types</a></li><li><a href="#equal2">Polymorphic Binary Types</a></li><li><a href="#default-aliases">Default Aliases</a></li></ul></li></ul></li><li><a href="#comparisons">Comparisons</a><ul><li><a href="#example">Example</a></li><li><a href="#comparison_functions">Comparison functions</a></li><li><a href="#monomorphic-types">Monomorphic Types</a></li><li><a href="#polymorphic-unary-types">Polymorphic Unary Types</a></li><li><a href="#polymorphic-binary-types">Polymorphic Binary Types</a></li><li><a href="#default-aliases">Default Aliases</a></li><li><a href="#physical_equality">Physical Equality</a><ul><li><a href="#monomorphic_comparison">Monomorphic Comparison</a></li></ul></li></ul></li><li><a href="#comparison_with_stdlib">Comparison with Stdlib</a><ul><li><a href="#monomorphic-comparison">Monomorphic Comparison</a></li><li><a href="#ordering-type">Ordering Type</a></li><li><a href="#equality-operators">Equality Operators</a></li></ul></li></ul></nav></header><section><header><h2 id="ordering"><a href="#ordering" class="anchor"></a>Ordering</h2><p>Ordering values are produced by <i>comparators</i> - functions that compare two values. Comparators for common data types can be found in the <a href="Comparator/index.html"><code>Comparator</code></a> module.</p><p>The complementary <a href="Ordering/index.html"><code>Ordering</code></a> module includes operations on <code>ordering</code> values.</p></header><section><header><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml">open Order

(* 2 &lt; 2 *)
let compare = Comparator.int in
assert (is Less (compare 1 2));

(* [1; 2] = [1; 2] *)
let compare = Comparator.(list int) in
assert (is Equal (compare [1; 2]));

(* (42, &quot;abc&quot;) &gt; (42, &quot;def&quot;) *)
let compare = Comparator.(pair int string) in
assert (is Greater (compare (42, &quot;abc&quot;) (42, &quot;def&quot;)));</code></pre></header><dl><dt class="spec type" id="type-ordering"><a href="#type-ordering" class="anchor"></a><code><span class="keyword">type</span> ordering</code> = <code>[ </code><table class="variant"><tr id="type-ordering.Less" class="anchored"><td class="def constructor"><a href="#type-ordering.Less" class="anchor"></a><code>| </code><code>`Less</code></td><td class="doc"><p><em>a &lt; b</em>, <em>a</em> is less than <em>b</em>.</p></td></tr><tr id="type-ordering.Equal" class="anchored"><td class="def constructor"><a href="#type-ordering.Equal" class="anchor"></a><code>| </code><code>`Equal</code></td><td class="doc"><p><em>a = b</em>, <em>a</em> is equal to <em>b</em>.</p></td></tr><tr id="type-ordering.Greater" class="anchored"><td class="def constructor"><a href="#type-ordering.Greater" class="anchor"></a><code>| </code><code>`Greater</code></td><td class="doc"><p><em>a &gt; b</em>, <em>a</em> is greater than <em>b</em>.</p></td></tr></table><code> ]</code></dt><dd><p>Defines the relative ordering of two values.</p></dd></dl><dl><dt class="spec module" id="module-Ordering"><a href="#module-Ordering" class="anchor"></a><code><span class="keyword">module</span> <a href="Ordering/index.html">Ordering</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for the <a href="index.html#type-ordering"><code>ordering</code></a> type.</p></dd></dl></section><section><header><h3 id="equality"><a href="#equality" class="anchor"></a>Equality</h3><p>Equality comparisons for monomorphic and polymorphic types.</p><p>This module defines interfaces and operations for equality comparison between values. Equality is an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>, which means that it must be: <i>reflexive</i>, <i>symmetric</i> and <i>transitive</i>.</p><p>User-defined types can implement the <a href="module-type-Equal0/index.html"><code>Equal0</code></a>, <a href="module-type-Equal1/index.html"><code>Equal1</code></a> or <a href="module-type-Equal2/index.html"><code>Equal2</code></a> interfaces (according to the arity of the main type) to include specialized equality comparison functions.</p><p><b>Note:</b> The extended version of <code>Equal</code> for polymorphic types does not include infix functions since they are only useful with two arguments and <code>Equal1</code> and <code>Equal2</code> would require extra arguments for each type parameter.</p></header><section><header><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml">open Order

module Book = struct
  type t = {
    title : string;
    author : string;
    isbn : int;
  }

  (* Equality by ISBN. *)
  include Equal0.Extend(struct
    type nonrec t = t

    let equal t1 t2 =
      Equality.string t1.isbn t2.isbn
  end)
end</code></pre></header></section><section><header><h4 id="equality_functions"><a href="#equality_functions" class="anchor"></a>Equality functions</h4></header><dl><dt class="spec type" id="type-equality"><a href="#type-equality" class="anchor"></a><code><span class="keyword">type</span> <span>'a equality</span></code><code> = <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dd><p>The type of equality testing functions.</p></dd></dl><dl><dt class="spec module" id="module-Equality"><a href="#module-Equality" class="anchor"></a><code><span class="keyword">module</span> <a href="Equality/index.html">Equality</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for the <a href="index.html#type-ordering"><code>ordering</code></a> function type. Includes implementations for common data types.</p></dd></dl></section><section><header><h4 id="equal"><a href="#equal" class="anchor"></a>Monomorphic Types</h4><p>Equality comparisons for monomorphic types, like integers and strings.</p></header><dl><dt class="spec module-type" id="module-type-Equal0"><a href="#module-type-Equal0" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Equal0/index.html">Equal0</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Base interface for equatable monomorphic types.</p></dd></dl><dl><dt class="spec module" id="module-Equal0"><a href="#module-Equal0" class="anchor"></a><code><span class="keyword">module</span> <a href="Equal0/index.html">Equal0</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Extension builder module for equatable monomorphic types.</p></dd></dl></section><section><header><h4 id="equal1"><a href="#equal1" class="anchor"></a>Polymorphic Unary Types</h4><p>Equality comparisons for polymorphic unary types, like lists and option values.</p></header><dl><dt class="spec module-type" id="module-type-Equal1"><a href="#module-type-Equal1" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Equal1/index.html">Equal1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Base interface for equatable polymorphic unary types.</p></dd></dl><dl><dt class="spec module" id="module-Equal1"><a href="#module-Equal1" class="anchor"></a><code><span class="keyword">module</span> <a href="Equal1/index.html">Equal1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Extension builder module for equatable monomorphic types.</p></dd></dl></section><section><header><h4 id="equal2"><a href="#equal2" class="anchor"></a>Polymorphic Binary Types</h4><p>Equality comparisons for polymorphic binary types, like results or either types.</p></header><dl><dt class="spec module-type" id="module-type-Equal2"><a href="#module-type-Equal2" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Equal2/index.html">Equal2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Base interface for equatable polymorphic binary types.</p></dd></dl><dl><dt class="spec module" id="module-Equal2"><a href="#module-Equal2" class="anchor"></a><code><span class="keyword">module</span> <a href="Equal2/index.html">Equal2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Extension builder module for equatable monomorphic types.</p></dd></dl></section><section><header><h4 id="default-aliases"><a href="#default-aliases" class="anchor"></a>Default Aliases</h4></header><dl><dt class="spec module-type" id="module-type-Equal"><a href="#module-type-Equal" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Equal/index.html">Equal</a> = <a href="index.html#module-type-Equal0">Equal0</a></code></dt><dd><p>Alias for extended interface for equatable monomorphic types.</p></dd></dl><dl><dt class="spec module" id="module-Equal"><a href="#module-Equal" class="anchor"></a><code><span class="keyword">module</span> Equal = <a href="index.html#module-Equal0">Equal0</a></code></dt><dd><p>Alias for interface builder for equatable monomorphic types.</p></dd></dl></section></section></section><section><header><h2 id="comparisons"><a href="#comparisons" class="anchor"></a>Comparisons</h2><p>This section defines types, interfaces and operations for values that form a total order relation.</p><p>An order is a total order if it is (for all <code>a</code>, <code>b</code> and <code>c</code>):</p><ul><li><i>total</i> and <i>antisymmetric</i>: exactly one of <code>a &lt; b</code>, <code>a = b</code> or <code>a &gt; b</code> is true;</li><li><i>transitive</i>, <code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code>. The same must hold for <code>=</code> and <code>&gt;</code>.</li></ul><p>User-defined types can implement the <a href="module-type-Ordered0/index.html"><code>Ordered0</code></a>, <a href="module-type-Ordered1/index.html"><code>Ordered1</code></a> or <a href="module-type-Ordered2/index.html"><code>Ordered2</code></a> interfaces (based on to the arity of the main type) to included a specialized comparison functions.</p></header><section><header><h5 id="example"><a href="#example" class="anchor"></a>Example</h5><pre><code class="ml">open Order

module Person = struct
  type t = {
    name : string;
    age : int;
  }

  (* Ordering by age. *)
  module By_age = Ordered0.Extend(struct
    type nonrec t = t

    let compare t1 t2 =
      Comparator.int t1.age t2.age
  end)
end

let alice = Person.{ name = &quot;Alice&quot;; age = 23 }
let bob   = Person.{ name = &quot;Bob&quot;;   age = 28 }
let craig = Person.{ name = &quot;Craig&quot;; age = 43 }

let () =
  assert Person.By_age.(bob &gt; alice);
  assert Person.By_age.(max bob craig = craig);
  assert Person.By_age.(bob |&gt; between ~min:alice ~max:craig)</code></pre></header></section><section><header><h4 id="comparison_functions"><a href="#comparison_functions" class="anchor"></a>Comparison functions</h4></header><dl><dt class="spec type" id="type-comparator"><a href="#type-comparator" class="anchor"></a><code><span class="keyword">type</span> <span>'a comparator</span></code><code> = <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><a href="index.html#type-ordering">ordering</a></code></dt><dd><p>The type of order comparison functions.</p><p>Multiple comparators can be composed to handle complex polymorphic types. The <a href="Comparator/index.html"><code>Comparator</code></a> module defines comparison functions for common monomorphic and polymorphic types and can be used for that.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><p>An arrays of optional pairs with ints and strings can be compared with:</p><pre><code class="ml">let my_compare =
  Comparator.(array (option (pair int string)))

let () =
  let a1 = [|Some (42, &quot;foo&quot;); Some (43, &quot;bar&quot;); Some (100, &quot;a&quot;)|] in
  let a2 = [|Some (42, &quot;foo&quot;); Some (10, &quot;baz&quot;); None|] in

  (* a1 is greater than a2 because the nested 43 is greater than 10. *)
  assert (is Greater (my_compare a1 a2));

  (* The composed comparator can also be used inline: *)
  assert (is Less Comparator.(array (option (pair int string)) a2 a1))</code></pre></dd></dl><dl><dt class="spec module" id="module-Comparator"><a href="#module-Comparator" class="anchor"></a><code><span class="keyword">module</span> <a href="Comparator/index.html">Comparator</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for the <a href="index.html#type-comparator"><code>comparator</code></a> function type. Includes implementations for common data types.</p></dd></dl></section><section><header><h4 id="monomorphic-types"><a href="#monomorphic-types" class="anchor"></a>Monomorphic Types</h4><p>Ordering comparisons for monomorphic types.</p></header><dl><dt class="spec module-type" id="module-type-Ordered0"><a href="#module-type-Ordered0" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Ordered0/index.html">Ordered0</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Base interface for ordered types.</p></dd></dl><dl><dt class="spec module" id="module-Ordered0"><a href="#module-Ordered0" class="anchor"></a><code><span class="keyword">module</span> <a href="Ordered0/index.html">Ordered0</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Extension builder module for ordered monomorphic types.</p></dd></dl></section><section><header><h4 id="polymorphic-unary-types"><a href="#polymorphic-unary-types" class="anchor"></a>Polymorphic Unary Types</h4><p>Ordering comparisons for polymorphic unary types.</p></header><dl><dt class="spec module-type" id="module-type-Ordered1"><a href="#module-type-Ordered1" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Ordered1/index.html">Ordered1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Base interface for ordered types.</p></dd></dl><dl><dt class="spec module" id="module-Ordered1"><a href="#module-Ordered1" class="anchor"></a><code><span class="keyword">module</span> <a href="Ordered1/index.html">Ordered1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Extension builder module for ordered polymorphic unary types.</p></dd></dl></section><section><header><h4 id="polymorphic-binary-types"><a href="#polymorphic-binary-types" class="anchor"></a>Polymorphic Binary Types</h4><p>Ordering comparisons for polymorphic binary types.</p></header><dl><dt class="spec module-type" id="module-type-Ordered2"><a href="#module-type-Ordered2" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Ordered2/index.html">Ordered2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Base interface for ordered types.</p></dd></dl><dl><dt class="spec module" id="module-Ordered2"><a href="#module-Ordered2" class="anchor"></a><code><span class="keyword">module</span> <a href="Ordered2/index.html">Ordered2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Extension builder module for ordered polymorphic binary types.</p></dd></dl></section><section><header><h4 id="default-aliases"><a href="#default-aliases" class="anchor"></a>Default Aliases</h4></header><dl><dt class="spec module-type" id="module-type-Ordered"><a href="#module-type-Ordered" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Ordered/index.html">Ordered</a> = <a href="index.html#module-type-Ordered0">Ordered0</a></code></dt><dd><p>Alias for extended interface for ordered monomorphic types.</p></dd></dl><dl><dt class="spec module" id="module-Ordered"><a href="#module-Ordered" class="anchor"></a><code><span class="keyword">module</span> Ordered = <a href="index.html#module-Ordered0">Ordered0</a></code></dt><dd><p>Alias for interface builder for ordered monomorphic types.</p></dd></dl></section><section><header><h3 id="physical_equality"><a href="#physical_equality" class="anchor"></a>Physical Equality</h3></header><dl><dt class="spec value" id="val-is"><a href="#val-is" class="anchor"></a><code><span class="keyword">val</span> is : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>is a b</code> tests for physical equality of <code>a</code> and <code>b</code>.</p><p>On mutable types such as references, arrays, byte sequences, records with mutable fields and objects with mutable instance variables, <code>is a b</code> is true if and only if physical modification of <code>a</code> also affects <code>b</code>. On non-mutable types, the behavior of <code>is</code> is implementation-dependent; however, it is guaranteed that <code>is a b</code> implies <code>a = b</code>.</p><p>To check if two values are physically distinct use <code>not (is a b)</code>.</p></dd></dl><dl><dt class="spec value" id="val-(==)"><a href="#val-(==)" class="anchor"></a><code><span class="keyword">val</span> (==) : <span>[ <span>`Deprecated of <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</span> ]</span></code></dt><dd><p>Using the <code>==</code> is discouraged because of its visual similarity with <code>=</code> and different semantics. The <a href="#val-is"><code>is</code></a> operator should be used instead.</p><p><b>Note:</b> This operator is included to raise a deprecation warning during compilation.</p></dd></dl><section><header><h4 id="monomorphic_comparison"><a href="#monomorphic_comparison" class="anchor"></a>Monomorphic Comparison</h4><p>Public comparison operations included when the top-level <code>Order</code> module is open.</p><p>By default the standard comparison functions are specialized to integers. To compare other types consider using the combinators provided in the <code>Equality</code> and <code>Comparator</code> modules. Alternatively you may consider opening the <a href="#magic"><code>Magic</code></a> module.</p></header><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span><a href="index.html#type-ordering">ordering</a></code></dt><dd><p>Produces the ordering between two integers.</p></dd></dl><dl><dt class="spec value" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span class="keyword">val</span> (=) : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a = b</code> tests if the integers <code>a</code> and <code>b</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&gt;) : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a &lt;&gt; b</code> tests if the integers <code>a</code> and <code>b</code> are <em>not</em> equal.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;)"><a href="#val-(&lt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;) : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a &lt; b</code> tests if the integer <code>a</code> is less than <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;)"><a href="#val-(&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;) : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a &gt; b</code> tests if the integer <code>a</code> is greater than <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;=)"><a href="#val-(&lt;=)" class="anchor"></a><code><span class="keyword">val</span> (&lt;=) : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a &lt;= b</code> tests if the integer <code>a</code> is less than or equal to <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;=)"><a href="#val-(&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;=) : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a &gt;= b</code> tests if the integer <code>a</code> is greater than or equal to <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>int</code></dt><dd><p>Takes the minimum of two integers.</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span class="arg">int <span>&#45;&gt;</span> </span><span class="arg">int <span>&#45;&gt;</span> </span>int</code></dt><dd><p>Takes the maximum of two integers.</p></dd></dl></section></section></section><section><header><h2 id="comparison_with_stdlib"><a href="#comparison_with_stdlib" class="anchor"></a>Comparison with Stdlib</h2><p>There are three main differences between Order and the OCaml standard library:</p><ul><li>The comparison operations implemented in the OCaml standard library are polymorphic, but in Order they are monomorphic (specialized to integers), by default.</li><li>In the OCaml standard library the base function used in all comparisons, <code>compare</code>, produces integer-based ordering values, while Order uses its own <a href="#type-ordering"><code>ordering</code></a> type.</li><li>Physical equality can be tested with <a href="#val-is"><code>is</code></a>, and the standard library's <a href="#val-(==)"><code>(==)</code></a> operator is deprecated.</li></ul><p>The following sections explain in detail the listed differences and the rationale behind them.</p></header><section><header><h4 id="monomorphic-comparison"><a href="#monomorphic-comparison" class="anchor"></a>Monomorphic Comparison</h4><p>The reason why polymorphic operations are not included in this library is because they are less efficient than the specialized versions and may cause runtime errors if functions, or other non-comparable values (like definitions in C bindings), are compared.</p><pre><code class="ml">let hello name =
  Printf.printf &quot;Hello, %s!&quot; name
in
  Pervasives.(hello = hello)
(* Exception: Invalid_argument &quot;compare: functional value&quot;. *)</code></pre><p>In this example it is clear that a function is being compared, but consider the case where a nested generic data type is being compared which happens to have a function value inside (like a comparator). The comparison will unexpectedly break.</p><p>Using monomorphic comparison eliminates the possibility of accidentally comparing functions and encourages the creation of custom comparators for user-defined types.</p></header></section><section><header><h4 id="ordering-type"><a href="#ordering-type" class="anchor"></a>Ordering Type</h4><p>The integer-based relative ordering is a historical artifact inherited from the low-level languages like C. As any convention not enforced by the type-system it can lead to errors, like accidentally using the ordering in numerical expressions or forgetting to handle a case. In ML languages ordering can be defined as a union type, providing clear semantics.</p></header></section><section><header><h4 id="equality-operators"><a href="#equality-operators" class="anchor"></a>Equality Operators</h4><p>Confusing for new-comers.</p><p>Inconsistent with type definition semantics:</p><pre><code class="ml">type type1 = type2 = A | B
let var1 = var2 = 1</code></pre></header></section></section></div></body></html>