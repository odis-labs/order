<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Order_magic (order.Order_magic)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">order</a> &#x00BB; Order_magic</nav><h1>Module <code>Order_magic</code></h1><nav class="toc"><ul><li><a href="#generic_equality">Polymorphic Equality</a></li><li><a href="#generic_ordering">Polymorphic Ordering</a></li></ul></nav></header><aside><p>Polymorphic <a href="https://blog.janestreet.com/the-perils-of-polymorphic-compare/">&quot;magic&quot;</a> functions for structural comparison.</p><pre><code class="ml">open Order.Magic

let () =
assert ('A' &lt; 'Z');
assert (max &quot;abc&quot; &quot;xyz&quot; = &quot;xyz&quot;)</code></pre><p><b>Warning:</b> The polymorphic functions in <code>Magic</code> are provided for convenience and must be used with care: they are less efficient than the specialized versions and may cause runtime errors if functions, or other non-comparable values, are compared. Instead of using <span class="xref-unresolved" title="unresolved reference to &quot;Magic.min&quot;"><code>Magic</code>.min</span> prefer the monomorphic <a href="index.html#val-min"><code>min</code></a> if you are working with integer values. Custom data types can implement their own specialized <a href="#equality">equality</a> and <a href="#ordering">ordering</a> interfaces.</p></aside><section><header><h3 id="generic_equality"><a href="#generic_equality" class="anchor"></a>Polymorphic Equality</h3></header><dl><dt class="spec value" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span class="keyword">val</span> (=) : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a = b</code> tests for structural equality of <code>a</code> and <code>b</code>. Mutable structures (<i>e.g.</i> references and arrays) are equal if and only if their current contents are structurally equal, even if the two mutable objects are not the same physical object (as tested with <code>is</code>).</p><dl><dt>raises Invalid_argument</dt><dd><p>if function values are compared for equality.</p><p><b>Warning:</b> Equality between cyclic data structures may not terminate.</p><p><b>See also:</b> <a href="#val-equal"><code>equal</code></a>, <a href="#val-is"><code>is</code></a></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&gt;) : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>a &lt;&gt; b</code> is <code>not (a = b)</code>, <i>i.e.</i>, the negation of <a href="index.html#val-(=)"><code>(=)</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><code>equal a b</code> is equivalent to <code>a == b</code>.</p></dd></dl></section><section><header><h3 id="generic_ordering"><a href="#generic_ordering" class="anchor"></a>Polymorphic Ordering</h3></header><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span><span class="type-var">'a</span> <a href="../Order/index.html#type-comparator">Order.comparator</a></span></code></dt><dd><p><code>compare a b</code> returns <code>0</code> if <code>a</code> is equal to <code>b</code>, <code>-1</code> if <code>a</code> is less than <code>b</code>, and <code>1</code> if <code>a</code> is greater than <code>b</code>. The ordering implemented by <code>compare</code> is compatible with the comparison predicates <code>==</code>, <code>&lt;</code> and <code>&gt;</code> defined above, with one difference on the treatment of the float value <code>nan</code>. Namely, the comparison predicates treat <code>nan</code> as different from any other float value, including itself; while <code>compare</code> treats <code>nan</code> as equal to itself and less than any other float value. This treatment of <code>nan</code> ensures that <code>compare</code> defines a total ordering relation.</p><dl><dt>raises Invalid_argument</dt><dd><p>if function values are compared for equality. <b>Warning:</b> Equality between cyclic data structures may not terminate.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-comparing"><a href="#val-comparing" class="anchor"></a><code><span class="keyword">val</span> comparing : <span class="arg"><span>(<span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> </span><span><span class="type-var">'a</span> <a href="../Order/index.html#type-comparator">Order.comparator</a></span></code></dt><dd><p>Applies a projection function to obtain a comparable value of type <code>'b</code>.</p><p><code>comparing f</code> is defined as <code>Comparator.by f Magic.compare</code>.</p><pre><code class="ml">type person = { name : string; age : int }

let by_age_descending : person comparator =
Comparator.descending (comparing (fun p -&gt; p.age))

let () =
  [{ name = &quot;Alice&quot;; age = 24 };
   { name = &quot;Bob&quot;;   age = 19 };
   { name = &quot;Craig&quot;; age = 45 }]
  |&gt; List.sort (Comparator.to_integral by_age_descending)
  |&gt; List.iter (fun p -&gt; print_endline p.name)</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;)"><a href="#val-(&lt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;) : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dt class="spec value" id="val-(&gt;)"><a href="#val-(&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;) : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dt class="spec value" id="val-(&lt;=)"><a href="#val-(&lt;=)" class="anchor"></a><code><span class="keyword">val</span> (&lt;=) : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dt class="spec value" id="val-(&gt;=)"><a href="#val-(&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;=) : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span>bool</code></dt><dd><p><b>Structural ordering functions.</b></p><p>These functions coincide with the usual orderings over integers, characters, strings, byte sequences and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with <a href="index.html#val-(=)"><code>(=)</code></a>. As in the case of <a href="index.html#val-(=)"><code>(=)</code></a>, mutable structures are compared by contents.</p><dl><dt>raises Invalid_argument</dt><dd><p>if function values are compared for equality.</p><p><b>Warning:</b> Equality between cyclic data structures may not terminate.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="type-var">'a</span></code></dt><dd><p><code>min a b</code> returns the smaller of the two arguments. The result is unspecified if one of the arguments contains the float value <code>nan</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if function values are compared for equality.</p><p><b>Warning:</b> Equality between cyclic data structures may not terminate.</p><pre><code class="ml">assert (min 2 5 = 2);
assert (min [1; 2; 3] [2; 3; 4] = [1; 2; 3])</code></pre></dd></dl></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="type-var">'a</span></code></dt><dd><p><code>max a b</code> returns the greater of the two arguments. The result is unspecified if one of the arguments contains the float value <code>nan</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if function values are compared for equality.</p><p><b>Warning:</b> Equality between cyclic data structures may not terminate.</p><pre><code class="ml">assert (max 2 5 = 5);
assert (max [1; 2; 3] [2; 3; 4] = [2; 3; 4])</code></pre></dd></dl></dd></dl></section></div></body></html>